'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _mem = require('mem');

var _mem2 = _interopRequireDefault(_mem);

var _babylon = require('babylon');

var _codeFrame = require('@babel/code-frame');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _mem2.default)((text, { filePath = null, isTypeScript = false } = {}) => {
  const options = {
    allowImportExportEverywhere: true,
    allowSuperOutsideMethod: true,
    sourceFilename: filePath,
    plugins: ['asyncGenerators', 'classConstructorCall', 'classProperties', 'decorators2', 'doExpressions', 'dynamicImport', 'exportExtensions', 'functionBind', 'functionSent', 'jsx', 'objectRestSpread', isTypeScript ? 'typescript' : 'flow']
  };

  try {
    return tryScriptAndModule(_babylon.parse, text, options);
  } catch (error) {
    try {
      return tryScriptAndModule(_babylon.parseExpression, text, options);
    } catch (error2) {
      throw new SyntaxError((0, _codeFrame.codeFrameColumns)(text, error.loc, { highightCode: true }));
    }
  }
});


const tryScriptAndModule = (fn, text, options) => {
  try {
    return fn(text, _extends({}, options, { sourceType: 'module' }));
  } catch (error) {
    try {
      return fn(text, _extends({}, options, { sourceType: 'script' }));
    } catch (error2) {
      throw error;
    }
  }
};